use crate::a2l::debuginfo::{DbgDataType, VarInfo};
use crate::a2l::debuginfo::{DebugData, TypeInfo, make_simple_unit_name};
use std::collections::HashMap;

#[derive(Clone)]
pub(crate) struct SymbolInfo<'dbg> {
    pub(crate) name: String,
    pub(crate) _address: u64,
    pub(crate) _typeinfo: &'dbg TypeInfo,
    pub(crate) _unit_idx: usize,
    pub(crate) _function_name: &'dbg Option<String>,
    pub(crate) _namespaces: &'dbg [String],
    pub(crate) _is_unique: bool,
}

struct AdditionalSpec {
    function_name: Option<String>,
    simple_unit_name: Option<String>,
    namespaces: Vec<String>,
}

// find a symbol in the elf_info data structure that was derived from the DWARF debug info in the elf file
pub(crate) fn find_symbol<'a>(
    varname: &str,
    debug_data: &'a DebugData,
    dwarf_stringmapping: &HashMap<String, String>,
) -> Result<SymbolInfo<'a>, String> {
    // Extension seen in files generated by Vector tools:
    // The varname in a symbol link might contain additional information
    // var{Function:FuncName}{CompileUnit:UnitName_c}{Namespace:Global}"
    // This allows variables that occur in multiple files / functions / namespaces to be identified correctly
    let (plain_symbol, additional_spec) = get_additional_spec(varname);

    // split the a2l symbol name: e.g. "motortune.param._0_" -> ["motortune", "param", "_0_"]
    let components = split_symbol_components(plain_symbol);
    let components = components
        .iter()
        .map(|s| {
            // map the original name in the symbol link to the already obfuscated name in the debug data
            if let Some(mapped) = dwarf_stringmapping.get(*s) {
                mapped.as_str()
            } else {
                *s
            }
        })
        .collect::<Vec<_>>();
    let mut obfuscated_symbol = String::with_capacity(plain_symbol.len());
    obfuscated_symbol.push_str(components[0]);
    if components.len() > 1 {
        for component in components.iter().skip(1) {
            if !component.starts_with('[') {
                obfuscated_symbol.push('.');
            }
            obfuscated_symbol.push_str(component);
        }
    }

    // find the symbol in the symbol table
    match find_symbol_from_components(&components, &additional_spec, debug_data) {
        Ok(sym_info) => Ok(SymbolInfo {
            name: obfuscated_symbol,
            ..sym_info
        }),
        Err(find_err) => {
            println!("find_symbol_from_components failed: {}", find_err);
            // it was not found using the given varname; if this is name has a mangled form then try that instead
            if let Some(mangled) = debug_data.demangled_names.get(components[0]) {
                let mut components_mangled = components.clone();
                components_mangled[0] = mangled;
                if let Ok(sym_info) =
                    find_symbol_from_components(&components_mangled, &additional_spec, debug_data)
                {
                    let mangled_varname =
                        mangled.to_owned() + varname.strip_prefix(components[0]).unwrap();
                    return Ok(SymbolInfo {
                        name: mangled_varname,
                        ..sym_info
                    });
                }
            }

            Err(find_err)
        }
    }
}

fn find_symbol_from_components<'a>(
    components: &[&str],
    additional_spec: &Option<AdditionalSpec>,
    debug_data: &'a DebugData,
) -> Result<SymbolInfo<'a>, String> {
    // the first component of the symbol name is the name of the global variable.
    if let Some(varinfo_list) = debug_data.variables.get(components[0]) {
        // somtimes there are several variables with the same name in different files or functions
        // select the best one of them based on the additional_data
        let varinfo = select_varinfo(varinfo_list, additional_spec, debug_data);
        let is_unique = varinfo_list.len() == 1;

        // we also need the type in order to resolve struct members, etc.
        if let Some(vartype) = debug_data.types.get(&varinfo.typeref) {
            // all further components of the symbol name are struct/union members or array indices
            find_membertype(vartype, debug_data, components, 1, varinfo.address).map(
                |(addr, typeinfo)| SymbolInfo {
                    name: "".to_string(),
                    _address: addr,
                    _typeinfo: typeinfo,
                    _unit_idx: varinfo.unit_idx,
                    _function_name: &varinfo.function,
                    _namespaces: &varinfo.namespaces,
                    _is_unique: is_unique,
                },
            )
        } else {
            // this exists for completeness, but shouldn't happen with a correctly generated elffile
            // if the variable is present in the elffile, then the type should also be present
            if components.len() == 1 {
                Ok(SymbolInfo {
                    name: "".to_string(),
                    _address: varinfo.address,
                    _typeinfo: &TypeInfo {
                        datatype: DbgDataType::Uint8,
                        name: None,
                        unit_idx: usize::MAX,
                        _dbginfo_offset: 0,
                    },
                    _unit_idx: varinfo.unit_idx,
                    _namespaces: &varinfo.namespaces,
                    _function_name: &None,
                    _is_unique: is_unique,
                })
            } else {
                Err(format!(
                    "Remaining portion \"{}\" of \"{}\" could not be matched",
                    components[1..].join("."),
                    components.join(".")
                ))
            }
        }
    } else {
        Err(format!("Symbol \"{}\" does not exist", components[0]))
    }
}

fn select_varinfo<'a>(
    varinfo_list: &'a [VarInfo],
    additional_spec: &Option<AdditionalSpec>,
    debug_data: &DebugData,
) -> &'a VarInfo {
    if let Some(additional_spec) = additional_spec {
        let unit = &additional_spec.simple_unit_name;
        let func = &additional_spec.function_name;
        let ns = &additional_spec.namespaces;
        for vi in varinfo_list {
            if (unit.is_none() || *unit == make_simple_unit_name(debug_data, vi.unit_idx))
                && (func.is_none() || *func == vi.function)
                && *ns == vi.namespaces
            {
                return vi;
            }
        }
        // spec was NOT matched. In this case we simply continue as if the spec didin't exist
    }
    &varinfo_list[0]
}

// split up a string of the form
// var{Function:FuncName}{CompileUnit:UnitName_c}{Namespace:Global}"
fn get_additional_spec(varname_ext: &str) -> (&str, Option<AdditionalSpec>) {
    if let Some(pos) = varname_ext.find('{') {
        let (base, spec_str) = varname_ext.split_at(pos);
        // ex: base = "var", spec_str = "{Function:FuncName}{CompileUnit:UnitName_c}{Namespace:Global}"
        if let Some(spec_str) = spec_str.strip_prefix('{').and_then(|s| s.strip_suffix('}')) {
            // spec_str = "Function:FuncName}{CompileUnit:UnitName_c}{Namespace:Global"
            let mut add_spec = AdditionalSpec {
                function_name: None,
                simple_unit_name: None,
                namespaces: vec![],
            };
            for component in spec_str.split("}{") {
                // component = "Function:FuncName" / "CompileUnit:UnitName_c" / "Namespace:Global"
                if let Some(func_name) = component.strip_prefix("Function:") {
                    add_spec.function_name = Some(func_name.to_string());
                } else if let Some(nsname) = component.strip_prefix("Namespace:") {
                    add_spec.namespaces.push(nsname.to_string());
                } else if let Some(name) = component.strip_prefix("CompileUnit:") {
                    add_spec.simple_unit_name = Some(name.to_string());
                    // CompileUnit:... is the last interesting entry - skip the final {Namespace:Global}
                    break;
                }
            }

            (base, Some(add_spec))
        } else {
            (base, None)
        }
    } else {
        (varname_ext, None)
    }
}

// split the symbol into components
// e.g. "my_struct.array_field[5][6]" -> [ "my_struct", "array_field", "[5]", "[6]" ]
fn split_symbol_components(varname: &str) -> Vec<&str> {
    let mut components: Vec<&str> = Vec::new();

    for component in varname.split('.') {
        if let Some(idx) = component.find('[') {
            // "array_field[5][6]" -> "array_field", "[5][6]"
            let (name, indexstring) = component.split_at(idx);
            components.push(name);
            components.extend(indexstring.split_inclusive(']'));
        } else {
            components.push(component);
        }
    }

    components
}

// find the address and type of the current component of a symbol name
fn find_membertype<'a>(
    typeinfo: &'a TypeInfo,
    debug_data: &'a DebugData,
    components: &[&str],
    component_index: usize,
    address: u64,
) -> Result<(u64, &'a TypeInfo), String> {
    if component_index >= components.len() {
        Ok((address, typeinfo))
    } else {
        match &typeinfo.datatype {
            DbgDataType::Class {
                members,
                inheritance,
                ..
            } => {
                if let Some((membertype, offset)) = members.get(components[component_index]) {
                    let membertype = membertype.get_reference(&debug_data.types);
                    find_membertype(
                        membertype,
                        debug_data,
                        components,
                        component_index + 1,
                        address + offset,
                    )
                } else if let Some((baseclass_type, offset)) =
                    inheritance.get(components[component_index])
                {
                    let skip = usize::from(
                        components.len() > component_index + 1
                            && components[component_index + 1] == "_",
                    );
                    find_membertype(
                        baseclass_type,
                        debug_data,
                        components,
                        component_index + 1 + skip,
                        address + offset,
                    )
                } else {
                    Err(format!(
                        "There is no member \"{}\" in \"{}\"",
                        components[component_index],
                        components[..component_index].join(".")
                    ))
                }
            }
            DbgDataType::Struct { members, .. } | DbgDataType::Union { members, .. } => {
                if let Some((membertype, offset)) = members.get(components[component_index]) {
                    let membertype = membertype.get_reference(&debug_data.types);
                    find_membertype(
                        membertype,
                        debug_data,
                        components,
                        component_index + 1,
                        address + offset,
                    )
                } else {
                    Err(format!(
                        "There is no member \"{}\" in \"{}\"",
                        components[component_index],
                        components[..component_index].join(".")
                    ))
                }
            }
            DbgDataType::Array {
                dim,
                stride,
                arraytype,
                ..
            } => {
                let mut multi_index = 0;
                for (idx_pos, current_dim) in dim.iter().enumerate() {
                    let arraycomponent =
                        components.get(component_index + idx_pos).unwrap_or(&"_0_"); // default to first element if no more components are specified
                    let indexval = get_index(arraycomponent).ok_or_else(|| {
                        format!("could not interpret \"{arraycomponent}\" as an array index")
                    })?;
                    if indexval >= *current_dim as usize {
                        return Err(format!(
                            "requested array index {} in expression \"{}\", but the array only has {} elements",
                            indexval,
                            components.join("."),
                            current_dim
                        ));
                    }
                    multi_index = multi_index * (*current_dim) as usize + indexval;
                }

                let elementaddr = address + (multi_index as u64 * stride);
                find_membertype(
                    arraytype,
                    debug_data,
                    components,
                    component_index + dim.len(),
                    elementaddr,
                )
            }
            _ => {
                if component_index >= components.len() {
                    Ok((address, typeinfo))
                } else {
                    // could not descend further to match additional symbol name components
                    Err(format!(
                        "Remaining portion \"{}\" of \"{}\" could not be matched",
                        components[component_index..].join("."),
                        components.join(".")
                    ))
                }
            }
        }
    }
}

// before ASAP2 1.7 array indices in symbol names could not written as [x], but only as _x_
// this function will get the numerical index for either representation
fn get_index(idxstr: &str) -> Option<usize> {
    if (idxstr.starts_with('_') && idxstr.ends_with('_'))
        || (idxstr.starts_with('[') && idxstr.ends_with(']'))
    {
        let idxstrlen = idxstr.len();
        match idxstr[1..(idxstrlen - 1)].parse() {
            Ok(val) => Some(val),
            Err(_) => None,
        }
    } else {
        None
    }
}

// /// find a component of a symbol based on an offset from the base address
// /// For example this could be a particular array element or struct member
// pub(crate) fn find_symbol_by_offset<'a>(
//     base_symbol: &SymbolInfo<'a>,
//     offset: i32,
//     debug_data: &'a DebugData,
// ) -> Result<SymbolInfo<'a>, String> {
//     if offset < 0 || offset > base_symbol.typeinfo.get_size() as i32 {
//         return Err(format!(
//             "Offset {} is out of bounds for symbol \"{}\"",
//             offset, base_symbol.name
//         ));
//     }

//     let offset = offset as u64;

//     let iter = TypeInfoIter::new(&debug_data.types, base_symbol.typeinfo, false);
//     for (name, typeinfo, item_offset) in iter {
//         if item_offset == offset {
//             return Ok(SymbolInfo {
//                 name: format!("{}{}", base_symbol.name, name),
//                 address: item_offset + base_symbol.address,
//                 typeinfo,
//                 unit_idx: base_symbol.unit_idx,
//                 function_name: base_symbol.function_name,
//                 namespaces: base_symbol.namespaces,
//                 is_unique: base_symbol.is_unique,
//             });
//         }
//     }

//     Err(format!(
//         "Could not find a symbol component at offset {offset} from \"{}\"",
//         base_symbol.name
//     ))
// }
